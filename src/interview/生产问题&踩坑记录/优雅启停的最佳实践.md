# 优雅启停的最佳实践
<!--page header-->

最近梳理了Java应用实现优雅启停的完整的最佳执行步骤实践，供大家参考：

对于一个已经启动的应用，合理的停止步骤如下：

1.**Web应用将http流量切走**

如果是Web应用，需要先借助工具或命令，将登记在nginx或tgw中的转发信息临时移除，确保不再有新的流量来访问将要停止的应用

2.**触发停止应用的通知**

2.1 方式1，执行 kill -2

发送进程停止的信号，java应用中通过Runtime.getRuntime().addShutdownHook注册回调，用于运行在进程退出之前需要执行的逻辑。由于addShutdownHook可以注册多个回调，调用顺序并不明确，所以不是最佳方案，仅供参考。

2.2 方式2，通过访问指定url触发停止应用的操作

比如将应用改造为SpringBoot方式的应用，内置启用触发shutdown的EndPotint,其实就是提供一个指定的url，通过curl命令访问该url，然后在代码中运行在进程退出之前需要执行的逻辑.
(不是SpringBoot方式，只要是web应用都可以这样做)，注意这个url应该限制允许本地127.0.0.1的ip访问，且需要加上帐号密码的鉴权限制，建议也限制仅允许POST方式访问。

```bash
  output=$(curl -vvv -u ${USER}:${PASS} -X POST http://127.0.0.1:${SYS_PORT}${CONTEXT_PATH}/actuator/shutdown)
    echo "response is ${output}"
```

3.收到停止应用的通知后，执行的应用内流程如下:

3.1 在close Spring Context之前，先执行需要优先进行的操作：

3.1.1 调用内置Tomcat的停止连接方法 connector.pause();

3.1.2 调用其它按需实现的业务个性操作

比如某些重要的**线程池**需要提前执行shutdown并**等待完全关闭**，则需要逐个调用shutdown方法。如果有重要的定时任务在运行，比如跑批操作之类的，需要自行实现优雅的stop或shutdown，便于进程重新启动后能自动断点续作。

3.2 执行 Spring ApplicationContext的 context.close();

3.3 按需执行其它收尾操作。比如xxx.gracefulShutdown();

4.shell脚本轮询，**检测应用绑定的JMX端口是否存在**

如果端口存在， 说明进程还没退出，shell sleep一秒，继续轮询

5.**超过指定时间 ，强制kill**。轮询检测超过指定时间(比如90s)，进程仍未正常退出，则执行 kill -9 ，强行终止进程，一般情况下都不要走到这一步，走到了的话，建议排查进程不能及时终止的原因。

另外，对于一个应用，如果要优雅的启动，那么流程如下：

1.**检测进程是否存在**

进程已经存在的情况下，按照前面的流程先进行优雅的停止。

2.**备份out文件**。应用一般将标准输出流写到了out文件，而out文件没有按天滚动的机制，不停的追加，会导致文件越来越大，有的有几G以上，影响性能，因此需要将其重命名成带时间戳的备份文件，对于超过指定时间的备份out文件（比如超过3个月），最好也自动删除。

3.**调用启动应用的命令**

4.**shell脚本轮询，检测应用绑定的业务端口是否存在**

如果端口存在，说明进程已经启动，否则 shell sleep一秒，继续轮询

5.**访问指定url，触发应用的预热操作**

轮询检测进程已经正常绑定服务端口，则curl访问指定url，触发应用加载缓存等预热操作，然后等待一定时间(比如5S)

6.**Web应用将http流量切入**

如果是Web应用，需要先借助工具或命令，将登记在nginx或tgw中的转发信息进行恢复，确保有新的流量来访问已经就绪的应用

7.**超过指定时间 ，发出告警**

轮询检测超过指定时间(比如150s)，进程仍未正常绑定服务端口，则需要输出告警信息，用于监控分析。


<!--page footer-->
- 原文: <https://www.yuque.com/dabin-1eu6s/plc2v4/igzog4xhm6c9mddz>